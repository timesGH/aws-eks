name: Manage EKS Cluster via Terraform Cloud

on:
  workflow_dispatch:
    inputs:
      clusterName:
        description: 'Name of the EKS cluster'
        required: true
        default: 'my_eks_cluster'
      awsRegion:
        description: 'AWS Region for the cluster'
        required: true
        default: 'us-east-1'
      action:
        description: 'Infrastructure action (apply/destroy)'
        required: true
        default: 'apply'
        type: choice
        options:
          - apply
          - destroy

env:
  TF_WORKSPACE: "eks-demo"
  TF_ORG: "Honours"
  TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}

jobs:
  terraform:
    runs-on: ubuntu-latest
    outputs:
      cluster_name: ${{ steps.outputs.outputs.cluster_name }}
      region: ${{ steps.outputs.outputs.region }}
      ecr_repository_uri: ${{ steps.ecr.outputs.repository-uri }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Setup Terraform Cloud Configuration
      run: |
        mkdir -p ~/.terraform.d
        cat > ~/.terraform.d/credentials.tfrc.json <<EOF
        {
          "credentials": {
            "app.terraform.io": {
              "token": "${{ env.TF_API_TOKEN }}"
            }
          }
        }
        EOF
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_wrapper: false
    
    - name: Terraform Init
      run: terraform init
    
    - name: Set Terraform Variables
      run: |
        # Create a variables file for this run
        cat > terraform.auto.tfvars <<EOF
        cluster_name = "${{ github.event.inputs.clusterName }}"
        region = "${{ github.event.inputs.awsRegion }}"
        EOF
    
    - name: Terraform Plan
      run: terraform plan -out=tfplan
    
    - name: Terraform Apply/Destroy
      run: |
        if [[ "${{ github.event.inputs.action }}" == "apply" ]]; then
          terraform apply -auto-approve tfplan
        else
          terraform destroy -auto-approve
        fi
    
    - name: Capture Outputs
      id: outputs
      if: ${{ github.event.inputs.action == 'apply' }}
      run: |
        echo "cluster_name=$(terraform output -raw cluster_name)" >> $GITHUB_OUTPUT
        echo "region=$(terraform output -raw region)" >> $GITHUB_OUTPUT
    
    - name: Create ECR Repository
      id: ecr
      if: ${{ github.event.inputs.action == 'apply' }}
      run: |
        # Install AWS CLI
        pip install awscli
        
        # Configure AWS using Terraform outputs
        export AWS_REGION=${{ steps.outputs.outputs.region }}
        export AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
        export AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
        
        # Create ECR repository if it doesn't exist
        REPO_NAME="${{ github.event.repository.name }}"
        aws ecr describe-repositories --repository-names $REPO_NAME || \
        aws ecr create-repository --repository-name $REPO_NAME
        
        # Get repository URI
        REPO_URI=$(aws ecr describe-repositories --repository-names $REPO_NAME \
          --query 'repositories[0].repositoryUri' --output text)
        echo "repository-uri=$REPO_URI" >> $GITHUB_OUTPUT
    
    - name: Setup Post-deployment
      if: ${{ github.event.inputs.action == 'apply' }}
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      run: |
        chmod +x post-deploy.sh
        ./post-deploy.sh
        
    - name: Configure kubectl
      if: ${{ github.event.inputs.action == 'apply' }}
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      run: |
        # Update kubeconfig
        aws eks update-kubeconfig --region ${{ steps.outputs.outputs.region }} \
          --name ${{ steps.outputs.outputs.cluster_name }}
        
        # Test cluster connectivity
        kubectl get nodes
